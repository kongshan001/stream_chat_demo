# 异步生成器详解

> 基于 `examples/02_async_generator.py` 的深入解析

## 目录

- [什么是异步生成器？](#什么是异步生成器)
- [为什么需要异步生成器？](#为什么需要异步生成器)
- [异步生成器 vs 普通生成器](#异步生成器-vs-普通生成器)
- [async/await 底层原理](#asyncawait-底层原理)
- [代码逐行解析](#代码逐行解析)
- [事件循环机制](#事件循环机制)
- [运行测试](#运行测试)
- [实际应用场景](#实际应用场景)

---

## 什么是异步生成器？

**定义：** 异步生成器是结合了生成器和异步编程的特殊函数，使用 `async def` 和 `yield` 定义。

**核心特点：**
- ❗ 使用 `async def` 定义
- ❗ 使用 `yield` 产生值
- ❗ 使用 `async for` 消费
- ❗ 支持异步操作（await）
- ❗ 适合I/O密集型任务

**语法对比：**

| 特性 | 普通生成器 | 异步生成器 |
|------|-----------|-----------|
| 定义 | `def` | `async def` |
| 产生值 | `yield` | `yield` |
| 消费 | `for` | `async for` |
| 支持await | ❌ 否 | ✅ 是 |
| 使用场景 | CPU密集 | I/O密集 |

**简单示例：**
```python
# 普通生成器
def normal_generator():
    for i in range(3):
        yield i

# 异步生成器
async def async_generator():
    for i in range(3):
        await asyncio.sleep(0.1)  # 异步等待
        yield i
```

---

## 为什么需要异步生成器？

### 问题：同步生成器阻塞主线程

**普通生成器的局限：**
```python
import time

def fetch_data():
    """模拟耗时操作（同步）"""
    data = []
    for i in range(5):
        time.sleep(1)  # 阻塞1秒
        data.append(f"数据 {i}")
    return data

def process_data(data):
    """处理数据"""
    for item in data:
        time.sleep(0.5)  # 又阻塞0.5秒
        print(f"处理: {item}")

# 总耗时：5 × 1 + 5 × 0.5 = 7.5秒
process_data(fetch_data())
```

**问题：**
- 同步操作阻塞主线程
- 无法并发处理多个任务
- 用户体验差

### 解决：异步生成器 + 并发处理

```python
import asyncio

async def async_fetch_data():
    """异步获取数据"""
    for i in range(5):
        await asyncio.sleep(1)  # 不阻塞
        yield f"数据 {i}"

async def process_data_async():
    """异步处理数据"""
    async for item in async_fetch_data():
        await asyncio.sleep(0.5)  # 不阻塞
        print(f"处理: {item}")

# 总耗时：5 × 1 + 5 × 0.5 = 7.5秒
# 但可以并发处理多个任务！
```

**优势：**
- 不阻塞主线程
- 可以并发处理多个I/O操作
- 提高吞吐量
- 更好的用户体验

---

## 异步生成器 vs 普通生成器

### 功能对比表

| 特性 | 普通生成器 | 异步生成器 |
|------|-----------|-----------|
| **定义方式** | `def` | `async def` |
| **产生值** | `yield` | `yield` |
| **消费方式** | `for x in gen` | `async for x in agen` |
| **返回类型** | `<class 'generator'>` | `<class 'async_generator'>` |
| **支持await** | ❌ 不支持 | ✅ 支持 |
| **适用场景** | CPU密集任务 | I/O密集任务 |
| **并发能力** | 单线程 | 支持并发 |
| **性能特点** | 简单快速 | 适合IO操作 |

### 代码对比

**普通生成器：**
```python
def sync_gen():
    for i in range(3):
        yield i

# 消费
for value in sync_gen():
    print(value)
```

**异步生成器：**
```python
async def async_gen():
    for i in range(3):
        await asyncio.sleep(0.1)
        yield i

# 消费
async def main():
    async for value in async_gen():
        print(value)

asyncio.run(main())
```

### 性能对比示例

**同步版本（阻塞）：**
```python
import time

def sync_task(id):
    """同步任务"""
    for i in range(3):
        time.sleep(1)  # 阻塞1秒
        yield f"任务{id}: 第{i}步"

def run_sync():
    """运行同步任务"""
    start = time.time()
    for task_id in [1, 2, 3]:
        for value in sync_task(task_id):
            print(value)
    print(f"总耗时: {time.time() - start:.2f}秒")

# 输出：总耗时: 9.00秒（3个任务顺序执行）
```

**异步版本（非阻塞）：**
```python
import asyncio

async def async_task(id):
    """异步任务"""
    for i in range(3):
        await asyncio.sleep(1)  # 不阻塞
        yield f"任务{id}: 第{i}步"

async def consume_async(gen, id):
    """消费异步生成器"""
    async for value in gen:
        print(value)

async def run_async():
    """运行异步任务"""
    start = time.time()
    tasks = [
        consume_async(async_task(id), id)
        for id in [1, 2, 3]
    ]
    await asyncio.gather(*tasks)
    print(f"总耗时: {time.time() - start:.2f}秒")

# 输出：总耗时: 3.00秒（3个任务并发执行）
```

**结论：** 异步版本性能提升3倍！

---

## async/await 底层原理

### 1. 协程 (Coroutine) 机制

**什么是协程？**
```
协程 = 用户态轻量级线程
- 不需要操作系统调度
- 用户程序主动切换
- 切换开销极小
- 适合I/O密集型任务
```

**协程 vs 线程：**

| 特性 | 协程 | 线程 |
|------|------|------|
| **调度** | 用户程序 | 操作系统 |
| **切换开销** | 极小 | 较大 |
| **内存占用** | KB级别 | MB级别 |
| **创建数量** | 数十万 | 数百到数千 |
| **适合场景** | I/O密集 | CPU密集 |
| **同步原语** | 不需要 | 需要锁 |

### 2. 事件循环 (Event Loop)

**工作原理：**
```
┌─────────────────────────────────────┐
│         事件循环 (Event Loop)        │
│                                     │
│  ┌─────────────────────────────┐  │
│  │  任务队列 (Task Queue)        │  │
│  │  - 协程1                      │  │
│  │  - 协程2                      │  │
│  │  - 协程3                      │  │
│  └─────────────────────────────┘  │
│             ↓                     │
│  ┌─────────────────────────────┐  │
│  │  执行当前任务                │  │
│  │  遇到 await 时挂起          │  │
│  └─────────────────────────────┘  │
│             ↓                     │
│  ┌─────────────────────────────┐  │
│  │  I/O事件等待                │  │
│  │  - 网络请求                 │  │
│  │  - 文件操作                 │  │
│  │  - 定时器                   │  │
│  └─────────────────────────────┘  │
│             ↓                     │
│  ┌─────────────────────────────┐  │
│  │  事件就绪，恢复任务         │  │
│  └─────────────────────────────┘  │
│             ↓                     │
│      (循环继续)                  │
└─────────────────────────────────────┘
```

**事件循环伪代码：**
```python
def event_loop():
    """简化的异步事件循环"""
    tasks = deque()  # 任务队列
    ready = deque()  # 就绪队列

    while tasks:
        # 1. 从就绪队列获取任务
        if ready:
            task = ready.popleft()
        else:
            # 2. 没有就绪任务，等待I/O事件
            task = tasks.popleft()

        # 3. 执行任务
        try:
            # 执行到下一个 await
            result = task.send(None)

            if isinstance(result, Future):
                # 4. I/O操作，等待完成
                result.add_callback(
                    lambda: ready.append(task)
                )
                tasks.append(task)
            else:
                # 5. 继续执行
                ready.append(task)

        except StopIteration:
            # 6. 任务完成
            continue
```

### 3. await 的工作机制

**await = 暂停 + 让出控制权**

```python
async def example():
    print("1. 开始")
    await asyncio.sleep(1)  # 暂停1秒，让出控制权
    print("2. 恢复")
```

**执行过程：**
```
时间轴
  │
  ├─ T0: 执行 "print('1. 开始')"
  │
  ├─ T0: 遇到 await，暂停当前协程
  │     让出控制权给事件循环
  │
  ├─ T0-T1: 事件循环可以执行其他任务
  │
  ├─ T1: 定时器到期
  │
  ├─ T1: 事件循环恢复当前协程
  │
  └─ T1: 执行 "print('2. 恢复')"
```

### 4. async for 的工作机制

**async for vs for：**

| 特性 | for | async for |
|------|-----|-----------|
| **同步迭代** | ✅ 支持 | ❌ 不支持 |
| **异步迭代** | ❌ 不支持 | ✅ 支持 |
| **阻塞** | 阻塞 | 不阻塞 |
| **底层实现** | `__iter__` | `__aiter__` |

**async for 展开为：**
```python
# async for 写法
async for item in async_gen():
    print(item)

# 等价于
iterator = async_gen().__aiter__()
try:
    while True:
        item = await iterator.__anext__()
        print(item)
except StopAsyncIteration:
    pass
```

---

## 代码逐行解析

### 1. 基础异步生成器 (4-10行)

```python
async def async_basic():
    """基础异步生成器"""
    print("开始异步生成器")

    for i in range(3):
        await asyncio.sleep(0.5)
        yield f"异步数据 {i}\n"
```

**逐行解释：**

| 行号 | 代码 | 说明 |
|------|------|------|
| 4 | `async def async_basic():` | 定义异步生成器函数 |
| 6 | `print("开始异步生成器")` | 第一次 async for 时执行 |
| 8 | `await asyncio.sleep(0.5)` | 异步等待0.5秒，不阻塞 |
| 9 | `yield f"异步数据 {i}\n"` | 返回值并暂停 |

**执行时序：**
```
async for item in async_basic():
    print(item, end="")

T0: 执行 "开始异步生成器"
T0: await sleep(0.5) → 暂停，让出控制权
T0-T0.5: 其他任务可以执行
T0.5: 恢复，yield "异步数据 0\n"
T0.5: await sleep(0.5) → 再次暂停
T0.5-T1.0: 其他任务可以执行
T1.0: 恢复，yield "异步数据 1\n"
...
```

### 2. 模拟AI思考过程 (13-25行)

```python
async def async_simulate_thinking():
    """模拟AI思考过程"""
    thinking_steps = [
        "理解问题...",
        "搜索知识库...",
        "分析上下文...",
        "构建回答...",
        "生成内容...",
    ]

    for step in thinking_steps:
        yield step
        await asyncio.sleep(0.3)
```

**应用场景：**
- AI思考过程可视化
- 显示"正在搜索知识库..."
- 让用户知道AI在工作

**执行流程：**
```
async for step in async_simulate_thinking():
    print(f"  {step}")

T0: yield "理解问题..." → 打印
T0: await sleep(0.3) → 暂停
T0.3: yield "搜索知识库..." → 打印
T0.3: await sleep(0.3) → 暂停
T0.6: yield "分析上下文..." → 打印
...
```

### 3. 逐词流式输出 (28-34行)

```python
async def async_word_stream(text):
    """将文本逐词流式输出"""
    words = text.split()

    for word in words:
        yield word + " "
        await asyncio.sleep(0.1)
```

**功能：**
- 将文本按空格分割
- 逐词输出
- 每词间隔0.1秒

**使用示例：**
```python
text = "AI流式输出让对话更加自然流畅"
await consume_async_generator(async_word_stream(text))
```

输出：
```
AI 流式 输出 让 对话 更加 自然 流畅
```

### 4. 消费异步生成器 (37-40行)

```python
async def consume_async_generator(generator):
    """消费异步生成器的示例"""
    async for item in generator:
        print(item, end="", flush=True)
```

**关键点：**
- 使用 `async for` 消费
- `flush=True` 实时输出
- 不阻塞其他任务

### 5. 主函数 (43-61行)

```python
async def main():
    print("=" * 50)
    print("1. 基础异步生成器")
    print("=" * 50)
    await consume_async_generator(async_basic())

    print("\n" + "=" * 50)
    print("2. 模拟AI思考过程")
    print("=" * 50)
    async for step in async_simulate_thinking():
        print(f"  {step}")
        await asyncio.sleep(0.2)

    print("\n" + "=" * 50)
    print("3. 逐词流式输出")
    print("=" * 50)
    text = "AI流式输出让对话更加自然流畅"
    await consume_async_generator(async_word_stream(text))
    print()


if __name__ == "__main__":
    asyncio.run(main())
```

**入口：**
```python
asyncio.run(main())
```
- 创建新的事件循环
- 运行 `main()` 协程
- 自动清理

---

## 事件循环机制

### 1. 创建事件循环

**方法1：asyncio.run()（推荐）**
```python
async def main():
    print("Hello")

asyncio.run(main())
```

**方法2：手动管理**
```python
loop = asyncio.new_event_loop()
asyncio.set_event_loop(loop)
try:
    loop.run_until_complete(main())
finally:
    loop.close()
```

### 2. 并发执行任务

**asyncio.gather()**
```python
async def task1():
    print("任务1开始")
    await asyncio.sleep(2)
    print("任务1完成")

async def task2():
    print("任务2开始")
    await asyncio.sleep(1)
    print("任务2完成")

async def main():
    # 并发执行
    await asyncio.gather(task1(), task2())

asyncio.run(main())
```

输出：
```
任务1开始
任务2开始
任务2完成  # 1秒后
任务1完成  # 2秒后
总耗时: 2秒（不是3秒！）
```

**asyncio.create_task()**
```python
async def main():
    # 创建任务，不立即等待
    task1 = asyncio.create_task(task1())
    task2 = asyncio.create_task(task2())

    # 等待两个任务完成
    await task1
    await task2
```

### 3. 异步生成器 + 并发

**示例：同时流式处理多个请求**
```python
async def stream_response(user_id):
    """流式响应"""
    for i in range(5):
        await asyncio.sleep(0.1)
        yield f"用户{user_id}: 消息{i}"

async def process_stream(stream, user_id):
    """处理流"""
    async for msg in stream:
        print(msg)

async def main():
    # 同时处理3个用户
    await asyncio.gather(
        process_stream(stream_response(1), 1),
        process_stream(stream_response(2), 2),
        process_stream(stream_response(3), 3),
    )

asyncio.run(main())
```

---

## 运行测试

### 1. 运行示例代码

```bash
python examples/02_async_generator.py
```

### 2. 输出示例

```
==================================================
1. 基础异步生成器
==================================================
开始异步生成器
异步数据 0
异步数据 1
异步数据 2

==================================================
2. 模拟AI思考过程
==================================================
  理解问题...
  搜索知识库...
  分析上下文...
  构建回答...
  生成内容...

==================================================
3. 逐词流式输出
==================================================
AI 流式 输出 让 对话 更加 自然 流畅
```

### 3. 性能测试

**同步版本 vs 异步版本：**
```python
import asyncio
import time

# 同步版本
def sync_tasks():
    start = time.time()
    for i in range(5):
        time.sleep(0.1)
        print(f"同步任务 {i}")
    print(f"同步耗时: {time.time() - start:.2f}秒")

# 异步版本
async def async_tasks():
    start = time.time()
    async def task(i):
        await asyncio.sleep(0.1)
        print(f"异步任务 {i}")

    await asyncio.gather(*[task(i) for i in range(5)])
    print(f"异步耗时: {time.time() - start:.2f}秒")

# 测试
print("=== 同步版本 ===")
sync_tasks()

print("\n=== 异步版本 ===")
asyncio.run(async_tasks())
```

输出：
```
=== 同步版本 ===
同步任务 0
同步任务 1
同步任务 2
同步任务 3
同步任务 4
同步耗时: 0.50秒

=== 异步版本 ===
异步任务 0
异步任务 1
异步任务 2
异步任务 3
异步任务 4
异步耗时: 0.10秒
```

**性能提升：5倍！**

---

## 实际应用场景

### 1. AI聊天应用（最重要）

```python
async def ai_response_stream(user_input):
    """AI流式响应"""
    # 1. 思考过程
    for step in ["理解问题", "搜索知识", "生成回答"]:
        yield {"type": "thinking", "content": step}
        await asyncio.sleep(0.5)

    # 2. 流式输出
    response = await generate_ai_response(user_input)
    for char in response:
        yield {"type": "content", "text": char}
        await asyncio.sleep(0.01)
```

### 2. 网络请求流式处理

```python
import aiohttp

async def fetch_url_stream(url):
    """流式获取网络数据"""
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            async for chunk in response.content.iter_chunked(1024):
                yield chunk

async def process_url(url):
    """处理URL数据"""
    async for chunk in fetch_url_stream(url):
        # 处理数据块
        process_chunk(chunk)

async def main():
    urls = ["url1", "url2", "url3"]
    await asyncio.gather(*[process_url(url) for url in urls])

asyncio.run(main())
```

### 3. 数据库异步查询

```python
import asyncpg

async def query_stream(conn, query):
    """异步查询流"""
    async for row in conn.cursor(query):
        yield row

async def process_database():
    """处理数据库"""
    conn = await asyncpg.connect("postgresql://...")
    async for row in query_stream(conn, "SELECT * FROM users"):
        print(row)
    await conn.close()
```

### 4. 文件异步读写

```python
import aiofiles

async def read_file_stream(filename):
    """异步读取文件流"""
    async with aiofiles.open(filename) as f:
        async for line in f:
            yield line.strip()

async def process_files(filenames):
    """处理多个文件"""
    await asyncio.gather(
        *[process_file(filename) for filename in filenames]
    )

async def process_file(filename):
    """处理单个文件"""
    async for line in read_file_stream(filename):
        print(f"{filename}: {line}")
```

### 5. WebSocket消息流

```python
import websockets

async def websocket_stream(url):
    """WebSocket消息流"""
    async with websockets.connect(url) as ws:
        async for message in ws:
            yield message

async def handle_websocket(url):
    """处理WebSocket"""
    async for message in websocket_stream(url):
        print(f"收到: {message}")
```

---

## 总结

### 异步生成器核心要点

1. **async def + yield**
   - 定义异步生成器
   - 支持异步操作
   - 适合I/O密集型任务

2. **async for**
   - 消费异步生成器
   - 不阻塞主线程
   - 可以并发执行

3. **事件循环**
   - 自动调度协程
   - 在I/O等待时切换任务
   - 提高并发性能

4. **性能优势**
   - 不阻塞
   - 可并发
   - 高吞吐量

5. **适用场景**
   - 网络请求
   - 文件操作
   - AI流式输出
   - 数据库查询

### 最佳实践

✅ **推荐做法：**
- I/O密集型任务使用异步生成器
- 使用 `asyncio.gather()` 并发执行
- 使用 `asyncio.sleep()` 而非 `time.sleep()`
- 合理控制并发数量

❌ **避免做法：**
- CPU密集型任务不要用异步
- 不要忘记 `await`
- 不要在异步生成器中执行同步阻塞操作
- 不要创建过多并发任务

---

## 扩展阅读

- [Python官方文档 - 异步生成器](https://docs.python.org/3/library/asyncio-generator.html)
- [PEP 525 - Asynchronous Generators](https://www.python.org/dev/peps/pep-0525/)
- [Real Python - Async IO in Python](https://realpython.com/async-io-python/)

---

掌握异步生成器，你就能构建高性能的流式应用！
